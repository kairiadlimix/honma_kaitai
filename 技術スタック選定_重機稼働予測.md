# 技術スタック選定：重機稼働予測ダッシュボード

## 1. 選定方針

### 1.1 選定基準

1. **開発速度**: PoCを迅速に構築できる
2. **保守性**: メンテナンスしやすい
3. **拡張性**: 将来の機能追加に対応可能
4. **既存環境との親和性**: AWS/Azure、kintoneとの連携
5. **学習コスト**: チームが習得しやすい技術

### 1.2 既存環境の活用

- **クラウド**: AWS / Azure（既存）
- **サーバーレス**: AWS Lambda（既存）
- **外部システム**: kintone（既存）
- **コミュニケーション**: Slack（既存）

---

## 2. フロントエンド技術スタック

### 2.1 フレームワーク選定

#### ✅ 推奨: **Next.js (React)**

**選定理由**:
- **開発速度**: 豊富なテンプレート、すぐに開発開始可能
- **パフォーマンス**: SSR/SSGで高速表示
- **TypeScript対応**: 型安全性でバグ削減
- **API Routes**: バックエンドAPIも同じプロジェクトで開発可能
- **デプロイ**: Vercelで簡単デプロイ、AWSでも対応可能

**代替案**:
- **Vue.js + Nuxt.js**: 学習コストが低い、小規模チーム向け
- **React (CRA)**: シンプルだが、Next.jsの方が機能豊富

#### 決定: **Next.js 14 (App Router)**

---

### 2.2 UIライブラリ選定

#### ✅ 推奨: **shadcn/ui + Tailwind CSS**

**選定理由**:
- **カスタマイズ性**: コンポーネントを自由に編集可能
- **デザイン品質**: モダンで美しいUI
- **TypeScript**: 完全な型サポート
- **軽量**: 必要なコンポーネントのみ使用
- **アクセシビリティ**: 標準で対応

**代替案**:
- **Material-UI (MUI)**: 豊富なコンポーネント、ただしカスタマイズがやや難しい
- **Chakra UI**: シンプルで使いやすい、ただしデザインがやや限定的

#### 決定: **shadcn/ui + Tailwind CSS**

---

### 2.3 グラフ・チャートライブラリ選定

#### ✅ 推奨: **Recharts**

**選定理由**:
- **React統合**: Reactコンポーネントとして使用可能
- **TypeScript**: 完全な型サポート
- **カスタマイズ性**: 細かいスタイリングが可能
- **軽量**: 必要なチャートのみインポート
- **ドキュメント**: 充実したドキュメント

**代替案**:
- **Chart.js + react-chartjs-2**: 機能豊富だが、React統合がやや複雑
- **D3.js**: 高機能だが、学習コストが高い
- **Victory**: シンプルだが、カスタマイズがやや限定的

#### 決定: **Recharts**

**使用するチャート**:
- 折れ線グラフ: 稼働時間推移、コスト推移
- 棒グラフ: クラス別比較、月次比較
- 円グラフ: コスト内訳
- ランキング表: テーブル形式

---

### 2.4 状態管理選定

#### ✅ 推奨: **TanStack Query (React Query) + Zustand**

**選定理由**:
- **TanStack Query**: 
  - サーバー状態管理に最適
  - キャッシュ、リトライ、自動再取得
  - API呼び出しの簡素化
- **Zustand**: 
  - クライアント状態管理（UI状態など）
  - シンプルで軽量
  - Reduxより学習コストが低い

**代替案**:
- **Redux Toolkit**: 大規模アプリ向け、やや複雑
- **Context API**: 小規模なら十分だが、パフォーマンス懸念

#### 決定: **TanStack Query + Zustand**

---

### 2.5 フォーム管理選定

#### ✅ 推奨: **React Hook Form + Zod**

**選定理由**:
- **React Hook Form**: パフォーマンスが高い、バリデーションが簡単
- **Zod**: TypeScriptと統合、型安全なバリデーション
- **shadcn/ui統合**: 既存コンポーネントと相性が良い

#### 決定: **React Hook Form + Zod**

---

### 2.6 日付処理選定

#### ✅ 推奨: **date-fns**

**選定理由**:
- **軽量**: moment.jsより軽量
- **関数型**: 必要な関数のみインポート
- **TypeScript**: 完全な型サポート
- **Tree-shaking**: バンドルサイズ削減

#### 決定: **date-fns**

---

## 3. バックエンド技術スタック

### 3.1 APIフレームワーク選定

#### ✅ 推奨: **Next.js API Routes**

**選定理由**:
- **統合開発**: フロントエンドと同じプロジェクト
- **シンプル**: 小規模APIなら十分
- **デプロイ**: 同じ環境でデプロイ可能

**代替案**:
- **FastAPI (Python)**: データ処理が得意、ML統合が容易（将来拡張時）
- **Express.js (Node.js)**: 柔軟だが、別プロジェクトになる

#### 決定: **Next.js API Routes**（PoC段階）

**将来拡張時**: FastAPIを検討（ML予測機能追加時）

---

### 3.2 データベース選定

#### ✅ 推奨: **PostgreSQL**

**選定理由**:
- **リレーショナル**: 複雑なクエリに対応
- **集計機能**: ビュー、集計関数が豊富
- **拡張性**: 将来の機能追加に対応
- **クラウド対応**: AWS RDS、Azure Databaseで利用可能

**代替案**:
- **MySQL**: PostgreSQLと同等だが、機能がやや限定的
- **MongoDB**: NoSQLだが、集計が複雑

#### 決定: **PostgreSQL 15+**

---

### 3.3 ORM/クエリビルダー選定

#### ✅ 推奨: **Prisma**

**選定理由**:
- **TypeScript**: 完全な型サポート
- **マイグレーション**: スキーマ管理が簡単
- **開発体験**: 優れた開発ツール
- **パフォーマンス**: 効率的なクエリ生成

**代替案**:
- **TypeORM**: 機能豊富だが、学習コストが高い
- **Drizzle ORM**: 軽量だが、機能がやや限定的

#### 決定: **Prisma**

---

### 3.4 データ処理選定

#### ✅ 推奨: **Node.js + TypeScript**

**選定理由**:
- **統一言語**: フロントエンドと同じ言語
- **非同期処理**: 効率的なデータ処理
- **既存環境**: AWS LambdaでNode.jsが利用可能

**将来拡張時**: Python（Pandas、NumPy）を検討（ML予測機能追加時）

#### 決定: **Node.js + TypeScript**

---

## 4. インフラ・デプロイ

### 4.1 クラウド選定

#### ✅ 推奨: **AWS**（既存環境を活用）

**選定理由**:
- **既存環境**: 既にAWSを使用
- **Lambda**: 既存のサーバーレス基盤
- **RDS**: PostgreSQLのマネージドサービス
- **S3**: データストレージ

**構成**:
- **フロントエンド**: Vercel または AWS Amplify
- **バックエンドAPI**: Next.js API Routes（Vercel）または AWS Lambda
- **データベース**: AWS RDS PostgreSQL
- **ストレージ**: AWS S3（必要に応じて）

#### 決定: **AWS**（既存環境を活用）

---

### 4.2 デプロイ選定

#### ✅ 推奨: **Vercel**（フロントエンド + API）

**選定理由**:
- **Next.js最適化**: Next.jsに最適化されたプラットフォーム
- **簡単デプロイ**: Git連携で自動デプロイ
- **無料プラン**: PoC段階では無料で利用可能
- **パフォーマンス**: グローバルCDN

**代替案**:
- **AWS Amplify**: AWS統合、カスタマイズ性が高い
- **Netlify**: Vercelと同等

#### 決定: **Vercel**（PoC段階）

**本番環境**: AWS Amplifyまたは自社サーバーを検討

---

### 4.3 CI/CD選定

#### ✅ 推奨: **GitHub Actions**

**選定理由**:
- **無料**: パブリックリポジトリなら無料
- **統合**: GitHubと統合
- **柔軟性**: カスタムワークフロー

#### 決定: **GitHub Actions**

---

## 5. 外部連携

### 5.1 kintone連携

#### ✅ 推奨: **@kintone/rest-api-client**

**選定理由**:
- **公式ライブラリ**: サイボウズ公式
- **TypeScript**: 型サポート
- **ドキュメント**: 充実

#### 決定: **@kintone/rest-api-client**

---

### 5.2 認証（将来拡張）

#### ✅ 推奨: **NextAuth.js**

**選定理由**:
- **Next.js統合**: Next.jsと相性が良い
- **多様なプロバイダー**: OAuth、JWTなど
- **セッション管理**: 自動セッション管理

#### 決定: **NextAuth.js**（将来拡張時）

---

## 6. 開発ツール

### 6.1 パッケージマネージャー

#### ✅ 推奨: **pnpm**

**選定理由**:
- **高速**: npm、yarnより高速
- **ディスク効率**: ディスク使用量が少ない
- **モノレポ対応**: 将来のモノレポ構成に対応

**代替案**:
- **npm**: 標準だが、やや遅い
- **yarn**: 高速だが、pnpmの方が効率的

#### 決定: **pnpm**

---

### 6.2 リンター・フォーマッター

#### ✅ 推奨: **ESLint + Prettier**

**選定理由**:
- **標準**: 業界標準
- **Next.js統合**: Next.jsのデフォルト設定
- **自動フォーマット**: コード品質向上

#### 決定: **ESLint + Prettier**

---

### 6.3 型チェック

#### ✅ 推奨: **TypeScript**

**選定理由**:
- **型安全性**: バグ削減
- **開発体験**: IDE補完が充実
- **標準**: モダンな開発の標準

#### 決定: **TypeScript**

---

## 7. 技術スタックまとめ

### 7.1 フロントエンド

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| フレームワーク | Next.js | 14+ |
| UIライブラリ | shadcn/ui + Tailwind CSS | Latest |
| グラフ | Recharts | Latest |
| 状態管理 | TanStack Query + Zustand | Latest |
| フォーム | React Hook Form + Zod | Latest |
| 日付処理 | date-fns | Latest |
| 言語 | TypeScript | 5+ |

### 7.2 バックエンド

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| API | Next.js API Routes | 14+ |
| データベース | PostgreSQL | 15+ |
| ORM | Prisma | Latest |
| 言語 | TypeScript | 5+ |

### 7.3 インフラ

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| クラウド | AWS | - |
| デプロイ | Vercel | - |
| データベース | AWS RDS PostgreSQL | 15+ |
| CI/CD | GitHub Actions | - |

### 7.4 外部連携

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| kintone | @kintone/rest-api-client | Latest |

---

## 8. 開発環境セットアップ

### 8.1 必要なツール

- **Node.js**: 18+ (LTS)
- **pnpm**: Latest
- **PostgreSQL**: 15+ (ローカル開発用)
- **Git**: Latest
- **VS Code**: Latest（推奨エディタ）

### 8.2 VS Code拡張機能

- ESLint
- Prettier
- Prisma
- Tailwind CSS IntelliSense
- TypeScript and JavaScript Language Features

---

## 9. パフォーマンス最適化

### 9.1 フロントエンド

- **コード分割**: Next.jsの自動コード分割
- **画像最適化**: Next.js Imageコンポーネント
- **キャッシュ**: TanStack Queryのキャッシュ機能
- **バンドルサイズ**: 必要なライブラリのみインポート

### 9.2 バックエンド

- **データベースインデックス**: 適切なインデックス設定
- **クエリ最適化**: Prismaのクエリ最適化
- **キャッシュ**: Redis（将来拡張時）

---

## 10. セキュリティ

### 10.1 フロントエンド

- **XSS対策**: Reactの自動エスケープ
- **CSRF対策**: Next.jsのCSRF保護

### 10.2 バックエンド

- **環境変数**: 機密情報は環境変数で管理
- **SQLインジェクション**: Prismaのパラメータ化クエリ
- **認証**: NextAuth.js（将来拡張時）

---

## 11. モニタリング・ログ（将来拡張）

### 11.1 エラートラッキング

- **Sentry**: エラー追跡
- **LogRocket**: セッションリプレイ

### 11.2 パフォーマンス監視

- **Vercel Analytics**: Vercelの分析機能
- **AWS CloudWatch**: AWS環境の監視

---

## 12. 次のステップ

1. **開発環境セットアップ**: ローカル環境の構築
2. **プロジェクト初期化**: Next.jsプロジェクト作成
3. **データベース設計**: Prismaスキーマ定義
4. **API設計**: エンドポイント設計
5. **UIコンポーネント設計**: shadcn/uiコンポーネント選定

